{ pkgs, lib }:

pkgs.writeShellApplication {
  name = "nixline-extract-config";

  runtimeInputs = with pkgs; [
    coreutils
    nix
  ];

  text = ''
    set -euo pipefail

    main() {
      show_usage() {
        cat << 'USAGE_EOF'
╔════════════════════════════════════════════════════════════╗
║                 NixLine Config Extractor                  ║
╚════════════════════════════════════════════════════════════╝

Extract configuration from existing files and generate .nixline.toml sections
for seamless migration to parameterized packs.

Usage:
  nixline-extract-config <file>              Extract config from specific file
  nixline-extract-config --auto              Auto-discover and extract all configs
  nixline-extract-config --list              List supported file types
  nixline-extract-config --examples          Show example configurations

Options:
  <file>         Path to configuration file to extract from
  --auto         Automatically discover and extract from all supported files
  --list         Show supported configuration file types
  --examples     Generate example .nixline.toml configurations
  --output FILE  Write output to file instead of stdout
  --help, -h     Show this help message

Examples:
  # Extract from specific file
  nixline-extract-config .editorconfig

  # Auto-discover all configs in current directory
  nixline-extract-config --auto

  # Generate example configurations for all packs
  nixline-extract-config --examples

  # Save to configuration file
  nixline-extract-config --auto --output .nixline.toml

The extracted configuration can be used in .nixline.toml to customize
parameterized packs with your existing settings.

USAGE_EOF
      }

      # Parse arguments
      EXTRACT_FILE=""
      AUTO_MODE=false
      LIST_MODE=false
      EXAMPLES_MODE=false
      OUTPUT_FILE=""

      if [[ $# -eq 0 ]]; then
        show_usage
        exit 1
      fi

      while [[ $# -gt 0 ]]; do
        case $1 in
          --help|-h)
            show_usage
            exit 0
            ;;
          --auto)
            AUTO_MODE=true
            shift
            ;;
          --list)
            LIST_MODE=true
            shift
            ;;
          --examples)
            EXAMPLES_MODE=true
            shift
            ;;
          --output)
            if [[ $# -lt 2 ]]; then
              echo "Error: --output requires a filename" >&2
              exit 1
            fi
            OUTPUT_FILE="$2"
            shift 2
            ;;
          *)
            if [[ -z "$EXTRACT_FILE" && "$AUTO_MODE" == false ]]; then
              EXTRACT_FILE="$1"
            else
              echo "Error: Unexpected argument '$1'" >&2
              exit 1
            fi
            shift
            ;;
        esac
      done

      # Execute based on mode
      if [[ "$LIST_MODE" == true ]]; then
        list_supported_files
      elif [[ "$EXAMPLES_MODE" == true ]]; then
        generate_examples
      elif [[ "$AUTO_MODE" == true ]]; then
        auto_extract_configs
      elif [[ -n "$EXTRACT_FILE" ]]; then
        extract_from_file "$EXTRACT_FILE"
      else
        echo "Error: No file specified or mode selected" >&2
        show_usage
        exit 1
      fi
    }

    list_supported_files() {
      echo "Supported configuration files:"
      echo ""
      echo "Universal Configs:"
      echo "  .editorconfig       - Editor formatting standards"
      echo "  .prettierrc         - Prettier code formatting"
      echo "  .yamllint           - YAML linting rules"
      echo "  LICENSE, LICENSE.txt - License information"
      echo ""
      echo "JavaScript/TypeScript:"
      echo "  .eslintrc.json      - ESLint linting rules"
      echo "  .eslintrc.js        - ESLint linting rules"
      echo ""
      echo "Python:"
      echo "  .flake8             - Python code quality checking"
      echo ""
      echo "Note: More file types can be added to lib/config-extractors.nix"
    }

    generate_examples() {
      echo "# Example .nixline.toml configuration"
      echo "# Generated by NixLine Config Extractor"
      echo ""
      echo "[organization]"
      echo "name = \"MyCompany\""
      echo "security_email = \"security@mycompany.com\""
      echo "default_team = \"@MyCompany/maintainers\""
      echo ""

      # Use nix eval to generate example configurations

      echo "[packs]"
      echo "enabled = [\"editorconfig\", \"prettier\", \"eslint\", \"flake8\", \"yamllint\", \"license\"]"
      echo ""

      # Generate examples for each pack type
      echo "# EditorConfig example"
      echo "[packs.editorconfig]"
      echo "indent_style = \"space\""
      echo "indent_size = 4"
      echo "max_line_length = 100"
      echo "trim_trailing_whitespace = true"
      echo ""

      echo "# Prettier example"
      echo "[packs.prettier]"
      echo "print_width = 100"
      echo "single_quote = true"
      echo "trailing_comma = \"all\""
      echo ""

      echo "# ESLint example"
      echo "[packs.eslint]"
      echo "extends = [\"eslint:recommended\", \"@typescript-eslint/recommended\"]"
      echo "typescript_support = true"
      echo ""

      echo "# Flake8 example"
      echo "[packs.flake8]"
      echo "max_line_length = 88"
      echo "ignore = [\"E203\", \"W503\"]"
      echo ""

      echo "# License example"
      echo "[packs.license]"
      echo "type = \"MIT\""
      echo "holder = \"MyCompany, Inc.\""
      echo "year = \"2025\""
    }

    auto_extract_configs() {
      echo "╔════════════════════════════════════════════════════════════╗"
      echo "║              Auto-Extracting Configurations                ║"
      echo "╚════════════════════════════════════════════════════════════╝"
      echo ""

      local found_configs=false
      local output=""

      # Add header
      output+="# NixLine Configuration"
      output+=$'\n'"# Extracted from existing configuration files"
      output+=$'\n'"# Generated on $(date)"
      output+=$'\n'
      output+=$'\n'"[organization]"
      output+=$'\n'"name = \"CHANGEME\""
      output+=$'\n'"security_email = \"security@example.com\""
      output+=$'\n'"default_team = \"@CHANGEME/maintainers\""
      output+=$'\n'
      output+=$'\n'"[packs]"
      output+=$'\n'"enabled = ["

      local pack_names=()
      local detected_languages=()

      # Detect project languages from governance files
      echo "Detecting project languages..."

      if [[ -f "package.json" ]]; then
        echo "  ✓ JavaScript/TypeScript project detected (package.json)"
        detected_languages+=("javascript")
        pack_names+=("\"prettier\"" "\"editorconfig\"")

        # Check for specific JS/TS patterns in package.json
        if grep -q "eslint" package.json 2>/dev/null; then
          pack_names+=("\"eslint\"")
        fi
        if grep -q "typescript\|@types/" package.json 2>/dev/null; then
          echo "    - TypeScript detected"
        fi
      fi

      if [[ -f "pyproject.toml" || -f "setup.py" || -f "requirements.txt" ]]; then
        echo "  ✓ Python project detected"
        detected_languages+=("python")
        pack_names+=("\"bandit\"" "\"flake8\"" "\"editorconfig\"")

        if [[ -f "pyproject.toml" ]] && grep -q "black\|ruff" pyproject.toml 2>/dev/null; then
          echo "    - Black formatter detected"
        fi
      fi

      if [[ -f "Cargo.toml" ]]; then
        echo "  ✓ Rust project detected (Cargo.toml)"
        detected_languages+=("rust")
        pack_names+=("\"editorconfig\"")

        if grep -q "cargo-audit" Cargo.toml 2>/dev/null; then
          echo "    - Cargo audit detected"
        fi
      fi

      if [[ -f "go.mod" || -f "go.sum" ]]; then
        echo "  ✓ Go project detected"
        detected_languages+=("go")
        pack_names+=("\"editorconfig\"")
      fi

      if [[ -f "Dockerfile" || -f "docker-compose.yml" || -f "docker-compose.yaml" ]]; then
        echo "  ✓ Docker configuration detected"
        pack_names+=("\"security\"")
      fi

      # Always suggest universal packs
      pack_names+=("\"license\"" "\"codeowners\"" "\"security\"")

      # Check for each supported existing config file
      for config_file in .editorconfig .prettierrc .eslintrc.json .eslintrc.js .flake8 .yamllint LICENSE LICENSE.txt; do
        if [[ -f "$config_file" ]]; then
          echo "Found: $config_file"
          found_configs=true

          local pack_name
          case "$config_file" in
            .editorconfig) pack_name="editorconfig" ;;
            .prettierrc) pack_name="prettier" ;;
            .eslintrc.*) pack_name="eslint" ;;
            .flake8) pack_name="flake8" ;;
            .yamllint) pack_name="yamllint" ;;
            LICENSE*) pack_name="license" ;;
          esac

          pack_names+=("\"$pack_name\"")

          # Extract configuration using nix eval
          local extracted_config
          extracted_config=$(extract_config_with_nix "$config_file")

          if [[ -n "$extracted_config" ]]; then
            output+=$'\n'$'\n'"$extracted_config"
          fi
        fi
      done

      # Remove duplicates from pack names
      local unique_packs=()
      mapfile -t unique_packs < <(printf '%s\n' "''${pack_names[@]}" | sort -u)

      # Complete the pack list with proper TOML formatting
      output="''${output}$(printf '%s,' "''${unique_packs[@]}" | sed 's/,$//')]\n"

      # Add detected languages information
      if [[ ''${#detected_languages[@]} -gt 0 ]]; then
        output+=$'\n'"# Detected project languages: $(IFS=,; echo "''${detected_languages[*]}")"
        output+=$'\n'"# Suggested packs are based on detected languages and existing configs"
      fi

      local has_suggestions=$((''${#detected_languages[@]} > 0))

      if [[ "$found_configs" == false && "$has_suggestions" == 0 ]]; then
        echo "No supported configuration files or project languages detected."
        echo ""
        echo "Supported files: .editorconfig, .prettierrc, .eslintrc.json, .flake8, .yamllint, LICENSE"
        echo "Supported projects: JavaScript/TS (package.json), Python (pyproject.toml), Rust (Cargo.toml), Go (go.mod)"
        return 0
      fi

      echo ""
      if [[ ''${#detected_languages[@]} -gt 0 ]]; then
        echo "Detected languages: $(IFS=, ; echo "''${detected_languages[*]}")"
      fi
      if [[ "$found_configs" == true ]]; then
        echo "Found existing configuration files"
      fi
      echo "Suggested packs: $(printf '%s ' "''${unique_packs[@]//\"/}" | sed 's/ $//')"
      echo ""

      if [[ -n "$OUTPUT_FILE" ]]; then
        echo "$output" > "$OUTPUT_FILE"
        echo "Configuration saved to: $OUTPUT_FILE"
      else
        echo "Generated .nixline.toml configuration:"
        echo "────────────────────────────────────────"
        echo "$output"
      fi
    }

    extract_from_file() {
      local file_path="$1"

      if [[ ! -f "$file_path" ]]; then
        echo "Error: File $file_path does not exist" >&2
        exit 1
      fi

      echo "Extracting configuration from: $file_path"
      echo ""

      local extracted_config
      extracted_config=$(extract_config_with_nix "$file_path")

      if [[ -n "$extracted_config" ]]; then
        if [[ -n "$OUTPUT_FILE" ]]; then
          echo "$extracted_config" > "$OUTPUT_FILE"
          echo "Configuration saved to: $OUTPUT_FILE"
        else
          echo "$extracted_config"
        fi
      else
        echo "No configuration could be extracted from $file_path"
        echo "File type may not be supported yet."
        exit 1
      fi
    }

    extract_config_with_nix() {
      local file_path="$1"
      local content
      content=$(cat "$file_path")

      # Use nix eval to extract configuration
      # This is a simplified version - in practice, we'd use the full nix evaluation
      local pack_name
      case "$file_path" in
        .editorconfig)
          pack_name="editorconfig"
          extract_editorconfig_simple "$content"
          ;;
        .prettierrc)
          pack_name="prettier"
          extract_prettier_simple "$content"
          ;;
        .flake8)
          pack_name="flake8"
          extract_flake8_simple "$content"
          ;;
        LICENSE*)
          pack_name="license"
          extract_license_simple "$content"
          ;;
        *)
          echo ""
          ;;
      esac
    }

    extract_editorconfig_simple() {
      local content="$1"
      echo "[packs.editorconfig]"

      if echo "$content" | grep -q "indent_style.*space"; then
        echo "indent_style = \"space\""
      elif echo "$content" | grep -q "indent_style.*tab"; then
        echo "indent_style = \"tab\""
      fi

      local indent_size
      indent_size=$(echo "$content" | grep "indent_size" | sed 's/.*indent_size[[:space:]]*=[[:space:]]*//' | head -1)
      if [[ -n "$indent_size" ]]; then
        echo "indent_size = $indent_size"
      fi

      if echo "$content" | grep -q "trim_trailing_whitespace.*true"; then
        echo "trim_trailing_whitespace = true"
      fi
    }

    extract_prettier_simple() {
      local content="$1"
      echo "[packs.prettier]"

      local print_width
      print_width=$(echo "$content" | grep -o '"printWidth"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*//')
      if [[ -n "$print_width" ]]; then
        echo "print_width = $print_width"
      fi

      if echo "$content" | grep -q '"singleQuote"[[:space:]]*:[[:space:]]*true'; then
        echo "single_quote = true"
      fi

      if echo "$content" | grep -q '"semi"[[:space:]]*:[[:space:]]*false'; then
        echo "semi = false"
      fi
    }

    extract_flake8_simple() {
      local content="$1"
      echo "[packs.flake8]"

      local max_line
      max_line=$(echo "$content" | grep "max-line-length" | sed 's/.*max-line-length[[:space:]]*=[[:space:]]*//' | head -1)
      if [[ -n "$max_line" ]]; then
        echo "max_line_length = $max_line"
      fi

      local ignore
      ignore=$(echo "$content" | grep "ignore" | sed 's/.*ignore[[:space:]]*=[[:space:]]*//' | head -1)
      if [[ -n "$ignore" ]]; then
        local formatted_ignore
        formatted_ignore=$(printf '%s' "$ignore" | tr ',' '\n' | sed 's/.*/"&"/' | paste -sd, -)
        echo "ignore = [$formatted_ignore]"
      fi
    }

    extract_license_simple() {
      local content="$1"
      echo "[packs.license]"

      if echo "$content" | grep -qi "apache"; then
        echo "type = \"Apache-2.0\""
      elif echo "$content" | grep -qi "mit"; then
        echo "type = \"MIT\""
      fi

      local year
      year=$(echo "$content" | grep -o "Copyright.*[0-9]\{4\}" | grep -o "[0-9]\{4\}" | head -1)
      if [[ -n "$year" ]]; then
        echo "year = \"$year\""
      fi

      echo "holder = \"CHANGEME\""
    }

    # Main execution
    main "$@"
  '';
}