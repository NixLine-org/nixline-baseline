{ pkgs, lib, config ? {} }:

#
# GITIGNORE PACK (Parameterized)
#
# Generates .gitignore files with ecosystem-specific and organizational patterns.
# Prevents sensitive files, build artifacts, and environment-specific files
# from being committed to version control.
#
# Configuration via .nixline.toml:
#   [packs.gitignore]
#   ecosystems = ["python", "nodejs", "rust", "go"]
#   additional_patterns = ["*.local", ".myorg/"]
#   include_secrets = true
#

let
  # Default configuration
  cfg = config.gitignore or {};

  ecosystems = cfg.ecosystems or [];
  additionalPatterns = cfg.additional_patterns or [];
  includeSecrets = cfg.include_secrets or true;
  includeEditor = cfg.include_editor or true;
  includeOS = cfg.include_os or true;

  # Ecosystem-specific ignore patterns
  ecosystemPatterns = {
    python = [
      "# Python"
      "__pycache__/"
      "*.py[cod]"
      "*$py.class"
      "*.so"
      ".Python"
      "build/"
      "develop-eggs/"
      "dist/"
      "downloads/"
      "eggs/"
      ".eggs/"
      "lib/"
      "lib64/"
      "parts/"
      "sdist/"
      "var/"
      "wheels/"
      "*.egg-info/"
      ".installed.cfg"
      "*.egg"
      "MANIFEST"
      "# Virtual environments"
      ".env"
      ".venv"
      "env/"
      "venv/"
      "ENV/"
      "env.bak/"
      "venv.bak/"
      "# PyCharm"
      ".idea/"
      "# Jupyter"
      ".ipynb_checkpoints"
      "# pytest"
      ".pytest_cache/"
      ".coverage"
      "htmlcov/"
      ".tox/"
      ""
    ];

    nodejs = [
      "# Node.js"
      "node_modules/"
      "npm-debug.log*"
      "yarn-debug.log*"
      "yarn-error.log*"
      "lerna-debug.log*"
      ".npm"
      ".eslintcache"
      ".node_repl_history"
      "*.tgz"
      "*.tar.gz"
      ".yarn-integrity"
      ".env.local"
      ".env.development.local"
      ".env.test.local"
      ".env.production.local"
      "# Build outputs"
      ".next/"
      "out/"
      "build/"
      "dist/"
      "# TypeScript"
      "*.tsbuildinfo"
      "# Parcel"
      ".cache/"
      ".parcel-cache/"
      ""
    ];

    rust = [
      "# Rust"
      "target/"
      "Cargo.lock"
      "**/*.rs.bk"
      "*.pdb"
      ""
    ];

    go = [
      "# Go"
      "*.exe"
      "*.exe~"
      "*.dll"
      "*.so"
      "*.dylib"
      "*.test"
      "*.out"
      "go.work"
      "vendor/"
      ""
    ];

    docker = [
      "# Docker"
      ".dockerignore"
      "docker-compose.override.yml"
      ""
    ];

    java = [
      "# Java"
      "*.class"
      "*.log"
      "*.ctxt"
      ".mtj.tmp/"
      "*.jar"
      "*.war"
      "*.nar"
      "*.ear"
      "*.zip"
      "*.tar.gz"
      "*.rar"
      "hs_err_pid*"
      ""
    ];
  };

  # Security and secrets patterns
  secretsPatterns = lib.optionals includeSecrets [
    "# Secrets and sensitive files"
    "*.key"
    "*.pem"
    "*.p12"
    "*.pfx"
    ".env"
    ".env.*"
    "secrets/"
    "credentials.json"
    "service-account.json"
    "*.credentials"
    ".aws/credentials"
    ".gcp/credentials"
    "config.json"
    ""
  ];

  # Editor and IDE patterns
  editorPatterns = lib.optionals includeEditor [
    "# Editors and IDEs"
    ".vscode/"
    ".idea/"
    "*.swp"
    "*.swo"
    "*~"
    ".DS_Store"
    "Thumbs.db"
    ""
  ];

  # Operating system patterns
  osPatterns = lib.optionals includeOS [
    "# Operating System"
    ".DS_Store"
    ".DS_Store?"
    "._*"
    ".Spotlight-V100"
    ".Trashes"
    "ehthumbs.db"
    "Thumbs.db"
    ""
  ];

  # Get patterns for specified ecosystems
  selectedEcosystemPatterns = lib.flatten (
    map (eco: ecosystemPatterns.${eco} or []) ecosystems
  );

  # Additional user-defined patterns
  userPatterns = if additionalPatterns != [] then
    ["# Additional organizational patterns"] ++ additionalPatterns ++ [""]
  else [];

  # Combine all patterns
  allPatterns = lib.flatten [
    ["# Generated by NixLine baseline"]
    ["# See https://git-scm.com/docs/gitignore for syntax"]
    [""]
    selectedEcosystemPatterns
    secretsPatterns
    editorPatterns
    osPatterns
    userPatterns
  ];

  gitignoreContent = lib.concatStringsSep "\n" allPatterns;

in
{
  files = {
    ".gitignore" = gitignoreContent;
  };

  checks = [
    {
      name = "gitignore-present";
      check = ''
        if [[ -f ".gitignore" ]]; then
          echo "[+] .gitignore found"
        else
          echo "[-] .gitignore missing"
          exit 1
        fi
      '';
    }
    {
      name = "gitignore-has-secrets-protection";
      check = lib.optionalString includeSecrets ''
        if grep -q "\.env" .gitignore 2>/dev/null; then
          echo "[+] .gitignore protects environment files"
        else
          echo "[!] Consider adding .env protection to .gitignore"
        fi
      '';
    }
  ];

  meta = {
    description = "Ecosystem-aware .gitignore file with security patterns";
    homepage = "https://git-scm.com/docs/gitignore";
    example = ''
      # Configuration in .nixline.toml:
      [packs.gitignore]
      ecosystems = ["python", "nodejs"]
      additional_patterns = ["*.local", ".myorg/"]
      include_secrets = true
    '';
    ecosystems = ecosystems;
  };
}